// –≠—Ç–æ—Ç –∫–æ–¥ –Ω—É–∂–Ω–æ –ø–æ–º–µ—Å—Ç–∏—Ç—å –≤ —Ñ–∞–π–ª ProjectBuilder.ts
import type { Anthropic as AnthropicType } from '@anthropic-ai/sdk';
import { Anthropic } from '@anthropic-ai/sdk';
import { execSync } from 'child_process';
import * as fs from 'fs-extra';
import * as path from 'path';
import * as ts from 'typescript';

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
interface ErrorFix {
  file: string;
  context: string;
  currentCode: string;
  suggestedFix: string;
  explanation: string;
  preserveLogic: boolean;
  type?: 'syntax' | 'module' | 'typescript' | 'import' | 'unknown';
  severity?: 'error' | 'warning';
}

interface ErrorPattern {
  pattern: RegExp;
  fix: (match: RegExpMatchArray, fileContent: string) => string;
  description: string;
}

// –£—Ç–∏–ª–∏—Ç–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ñ–∞–π–ª–∞–º–∏
class FileManager {
  static async readFile(filePath: string): Promise<string> {
    const absolutePath = path.resolve(process.cwd(), filePath);
    const content = await fs.readFile(absolutePath, 'utf8');
    console.log(`üìñ –ü—Ä–æ—á–∏—Ç–∞–Ω —Ñ–∞–π–ª: ${absolutePath}`);
    return content;
  }

  static async writeFile(filePath: string, content: string): Promise<void> {
    const absolutePath = path.resolve(process.cwd(), filePath);
    await fs.ensureDir(path.dirname(absolutePath));
    await fs.writeFile(absolutePath, content);
    console.log(`‚úçÔ∏è –ó–∞–ø–∏—Å–∞–Ω —Ñ–∞–π–ª: ${absolutePath}`);
  }

  static async backupFile(filePath: string): Promise<void> {
    const absolutePath = path.resolve(process.cwd(), filePath);
    const backupPath = `${absolutePath}.backup`;
    await fs.copy(absolutePath, backupPath);
    console.log(`üíæ –°–æ–∑–¥–∞–Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è: ${backupPath}`);
  }

  static isAllowedType(filePath: string, allowedTypes: string[]): boolean {
    const ext = path.extname(filePath);
    return allowedTypes.some(type => 
      type.startsWith('.') ? ext === type : filePath.includes(type)
    );
  }
}

// –û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å Builder
class Builder {
  private readonly anthropic: AnthropicType;
  private readonly maxAttempts = 5;
  private readonly allowedFileTypes = [
    '.ts', '.tsx', '.js', '.jsx', 
    'prisma/schema.prisma', 
    'next.config.js', 
    'package.json'
  ];

  private readonly errorPatterns: ErrorPattern[] = [
    {
      pattern: /Expression expected.*\n.*React\.forwardRef([^>]+)>/s,
      fix: (match, content) => content.replace(
        match[0],
        `React.forwardRef<${match[1].trim()}>`
      ),
      description: "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å React.forwardRef"
    },
    {
      pattern: /Module not found: Can't resolve '([^']+)'/,
      fix: (match, content) => {
        execSync(`npm install ${match[1]} --save`);
        return content;
      },
      description: "–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π –º–æ–¥—É–ª—å"
    },
    {
      pattern: /'import'.+cannot be used outside of module code/,
      fix: (match, content) => {
        const imports = content.match(/import[^;]+;/g) || [];
        return content.replace(/import[^;]+;/g, '') + imports.join('\n');
      },
      description: "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –∏–º–ø–æ—Ä—Ç–æ–≤"
    }
  ];

  constructor() {
    this.validateAndLogAPIKey();
    this.anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
  }

// –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ —Å–±–æ—Ä–∫–∏
 async buildProject(): Promise<boolean> {
   const startTime = Date.now();
   let attempts = 0;
   let lastErrors: string[] = [];

   while (attempts < this.maxAttempts) {
     try {
       console.log(`\nüîÑ –ü–æ–ø—ã—Ç–∫–∞ —Å–±–æ—Ä–∫–∏ #${attempts + 1}`);
       
       execSync('npm run build --loglevel verbose', { 
         stdio: 'pipe', 
         encoding: 'utf-8' 
       });
       
       const endTime = Date.now();
       console.log('üéâ –°–±–æ—Ä–∫–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
       console.log(`‚è±Ô∏è –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: ${endTime - startTime}–º—Å`);
       return true;
       
     } catch (error) {
       this.logSystemInfo();
       const errorDetails = this.extractDetailedErrorInfo(error);
       const currentErrors = this.parseErrors(errorDetails);
       const prioritizedErrors = await this.prioritizeErrors(currentErrors);
       
       if (this.areErrorsSame(lastErrors, prioritizedErrors)) {
         console.log('‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ –æ—à–∏–±–æ–∫, —Ç—Ä–µ–±—É–µ—Ç—Å—è –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥');
         break;
       }
       
       lastErrors = prioritizedErrors;
       attempts++;
       
       const fixed = await this.batchFixErrors(prioritizedErrors);
       if (!fixed) {
         console.log('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∏—Å–ø—Ä–∞–≤–∏—Ç—å –æ—à–∏–±–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏');
         break;
       }
     }
   }

   console.error('üö® –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç');
   return false;
 }

 // –ú–µ—Ç–æ–¥—ã –∞–Ω–∞–ª–∏–∑–∞ –æ—à–∏–±–æ–∫
 private extractDetailedErrorInfo(error: unknown): string {
   const errorLog = (error as any)?.stderr || (error as any)?.stdout || (error as Error)?.message;
   const filePath = this.findErrorFile(errorLog);
   return JSON.stringify({
     log: errorLog,
     file: filePath,
     context: this.findErrorContext(errorLog)
   });
 }

 private findErrorFile(log: string): string | null {
   const match = log.match(/in\s+([\w/.-]+\.(ts|tsx|js|jsx))/);
   return match ? match[1] : null;
 }

 private findErrorContext(log: string): string {
   const match = log.match(/error\s*(.{0,500})/s);
   return match ? match[1] : '–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç';
 }

 private parseErrors(errorLog: string): string[] {
   const errors: string[] = [];
   const lines = errorLog.split('\n');
   let currentError = '';
   
   lines.forEach(line => {
     if (line.includes('Error:') || line.includes('error TS')) {
       if (currentError) errors.push(currentError);
       currentError = line;
     } else if (currentError && line.trim()) {
       currentError += '\n' + line;
     }
   });

   if (currentError) errors.push(currentError);
   return errors;
 }

 // –ú–µ—Ç–æ–¥—ã –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫
 private async batchFixErrors(errors: string[]): Promise<boolean> {
   console.log(`üîÑ –ü–∞–∫–µ—Ç–Ω–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ${errors.length} –æ—à–∏–±–æ–∫...`);
   
   const fixes = await Promise.all(
     errors.map(error => this.getErrorFix(error))
   );

   const validFixes = fixes.filter((fix): fix is ErrorFix => fix !== null);
   
   if (validFixes.length === 0) {
     console.log('‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–∏–º–µ–Ω–∏–º—ã—Ö –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π');
     return false;
   }

   try {
     for (const fix of validFixes) {
       await this.applyFix(fix);
     }
     
     console.log(`‚úÖ –ü—Ä–∏–º–µ–Ω–µ–Ω–æ ${validFixes.length} –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π`);
     return true;
   } catch (error) {
     console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–∏:', error);
     return false;
   }
 }

  private getErrorContext(error: string): {type: string, severity: string} {
    if (error.includes('TS')) {
      return { type: 'typescript', severity: 'error' };
    }
    if (error.includes('Module not found')) {
      return { type: 'module', severity: 'error' };
    }
    if (error.includes('Syntax')) {
      return { type: 'syntax', severity: 'error' };
    }
    if (error.includes('warning')) {
      return { type: 'unknown', severity: 'warning' };
    }
    return { type: 'unknown', severity: 'error' };
  }

  private async getErrorFix(errorMessage: string): Promise<ErrorFix | null> {
    consol    consol    consol    consol    consol    consol   essage.slice(0, 100));
    
    const context = this.getErrorContext(errorMessage);
    
    for (const pattern of this.errorPatterns) {
      const match = errorMessage.match(pattern.pattern);
      if (match) {
        console.log(`‚ú® –ù–∞–π–¥–µ–Ω –ø–∞—Ç—Ç–µ—Ä–Ω: ${pattern.description}`);
        const filePath = this.findErrorFile(errorMessage);
        if (!filePath) continue;

        const fileContent = await FileManager.readFile(filePath);
        const fixedContent = pattern.fix(match, fileContent);

        return {
          file: filePath,
          context: pattern.description,
          currentCode: fileContent,
          suggestedFix: fixedContent,
          explanation: `–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ${pattern.description}`,
          preserveLogic: true,
          type: context.type,
          severity: context.severity
        };
      }
    }

    return this.getClaudeFix(errorMessage);
  }

  private async getClaudeFix   try {
     console.log('ü§ñ –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –ø–æ–º–æ—â—å Claude...');
     
     const response = await this.anthropic.messages.create({
       model: "claude-3-haiku-20240307",
       max_tokens: 4096,
       messages: [{
         role: "user",
         content: `
–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –æ—à–∏–±–∫—É —Å–±–æ—Ä–∫–∏ Next.js –∏ –ø—Ä–µ–¥–ª–æ–∂–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON:

–û—à–∏–±–∫–∞:
${errorMessage}

\`\`\`json
{
 "file": "–ø—É—Ç—å/–∫/—Ñ–∞–π–ª—É",
 "context": "–æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã",
 "currentCode": "–ø—Ä–æ–±–ª–µ–º–Ω—ã–π –∫–æ–¥",
 "suggestedFix": "–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∫–æ–¥",
 "explanation": "–ø–æ–¥—Ä–æ–±–Ω–æ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ",
 "preserveLogic": true
}
\`\`\`
`
       }]
     });

     const suggestionMatch = response.content[0].text.match(/```json\n([\s\S]*?)\n```/);
     if (!suggestionMatch) return null;

     const fix = JSON.parse(suggestionMatch[1]);
     console.log('‚úÖ –ü–æ–ª—É—á–µ–Ω–æ —Ä–µ—à–µ–Ω–∏–µ –æ—Ç Claude');
     return fix;

   } catch (error) {
     console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ Claude:', error);
     return null;
   }
 }

 // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
 private async applyFix(fix: ErrorFix): Promise<void> {
   if (!fix.file || !FileManager.isAllowedType(fix.file, this.allowedFileTypes)) {
     console.warn('‚ö†Ô∏è –ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π —Ç–∏–ø —Ñ–∞–π–ª–∞');
     return;
   }

   try {
     await FileManager.backupFile(fix.file);
     await FileManager.writeFile(fix.file, fix.suggestedFix);
     console.log(`‚úÖ –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ: ${fix.explanation}`);
   } catch (error) {
     console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è:', error);
   }
 }

 private areErrorsSame(prev: string[], curr: string[]): boolean {
   if (prev.length !== curr.length) return false;
   return prev.every((err, i) => this.normalizeError(err) === this.normalizeError(curr[i]));
 }

 private normalizeError(error: string): string {
   return error.replace(/[0-9]/g, '').replace(/\s+/g, ' ').trim();
 }

 private async prioritizeErrors(errors: string[]): Promise<string[]> {
   return errors.sort((a, b) => {
     if (a.includes('SyntaxError')) return -1;
     if (b.includes('SyntaxError')) return 1;
     if (a.includes('TypeError')) return -1;
     if (b.includes('TypeError')) return 1;
     return 0;
   });
 }

 private validateAndLogAPIKey(): void {
   if (!process.env.ANTHROPIC_API_KEY) {
     throw new Error('‚ùå API –∫–ª—é—á Anthropic –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ .env');
   }
   console.log("API –∫–ª—é—á: ‚úÖ –ü—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç");
 }

 private logSystemInfo(): void {
   console.group("üî¥ –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∫–∏");
   console.log("–°–∏—Å—Ç–µ–º–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è:", {
     platform: process.platform,
     nodeVersion: process.version,
     arch: process.arch
   });
   console.groupEnd();
 }
}

const builder = new Builder();
export default builder;
